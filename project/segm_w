https://habr.com/ru/post/439674/

https://karpathy.github.io/2016/05/31/rl/

https://towardsdatascience.com/introduction-to-image-segmentation-9636fa95922

Пример с к-mean и edge-detection https://www.analyticsvidhya.com/blog/2019/04/introduction-image-segmentation-techniques-python/


https://arxiv.org/pdf/2009.11212.pdf
https://arxiv.org/pdf/2007.03514.pdf
    
https://debuggercafe.com/introduction-to-image-segmentation-in-deep-learning/ -------
https://data-flair.training/blogs/image-segmentation-machine-learning/ --

https://neptune.ai/blog/image-segmentation-in-2020
---
https://arxiv.org/abs/1511.00561
https://paperswithcode.com/method/u-net
https://github.com/matterport/Mask_RCNN
https://github.com/facebookresearch/detectron2/blob/601d7666faaf7eb0ba64c9f9ce5811b13861fe12/detectron2/modeling/roi_heads/mask_head.py#L154
https://worksheets.codalab.org/worksheets/0xe2ac460eee7443438d5ab9f43824a819
https://github.com/tuananh1007/Semantic-Segmentation-Architectures-Implemented-in-PyTorch
---


https://github.com/zhixuhao/unet - example code

Что в целом делается при обработке изображения, получаемого от бота?

* Изображения уменьшаются от их исходного размера (например, 640 × 480) до меньшего разрешения (например, 80 × 60). Этот шаг ускоряет обучение нейронных сетей и вывод данных, в то время как изображение с меньшим разрешением по-прежнему предоставляет достаточно информации для навигации робота. 
* Обрезка: часть изображения, не содержащая полезной информации, обрезается. Обычно это делается над горизонтом.
* Цветовая сегментация: чтобы нейронной сети было легче распознавать важные части изображения, ключевые цвета сегментируются на основе их значений. 
* Нормализация: значения пикселей нормализуются до диапазона [0,1], что помогает быстрее обучать CNN.

Алгоритм K-средних - это итерационный метод, который используется для разделения изображения на K кластеров (грубо говоря - каринка на выходе будет состоять из к-различных цветов, то есть каждый пиксель перекрашивается под наиболее подходящий цвет)

    Выберите K кластерных центров либо случайным образом, либо на основе какого-либо эвристического метода, например K-means ++
    Назначьте каждый пиксель изображения кластеру, чтобы минимизировать расстояние(квадрат или абсолютная разница между пикселем и центром кластера) между пикселем и центром кластера.
    Пересчитайте центры кластера, усреднив все пиксели в кластере.
    Повторяйте шаги 2 и 3 до тех пор, пока не будет достигнута сходимость (т. Е. Кластеры не меняются)
    

#Архитектуры по сегментации изображения

## Небольшое введение

Семантическая сегментация - это подход, определяющий для каждого пикселя принадлежность к классу объекта. Например, когда все люди на фигуре сегментированы как один объект, а фон - как один объект.  
Сегментация экземпляров - это подход, который идентифицирует для каждого пикселя принадлежащий ему экземпляр объекта. Он обнаруживает каждый отдельный интересующий объект на изображении. Например, когда каждый человек на фигуре сегментируется как отдельный объект. 
  
Описания алгоритмов, которые вообще бывают при сегментации можно посмотреть тут [Wikipedia](https://en.wikipedia.org/wiki/Image_segmentation)


## VGG 

[Описание](https://iq.opengenus.org/vgg19-architecture/)

* Фиксированный размер изображения RGB (224 * 224) был задан в качестве входных данных для этой сети, что означает, что матрица имела форму (224 224,3).
* Единственная предварительная обработка, которая была произведена, заключалась в том, что они вычитали среднее значение RGB из каждого пикселя, вычисленное по всему обучающему набору.
* Использованы ядра размером (3 * 3) с размером шага 1 пиксель, что позволило им охватить все понятие изображения.
* пространственное заполнение использовалось для сохранения пространственного разрешения изображения.
* max pooling выполнялся над окнами размером 2 * 2 пикселя с шагом 2.
* за этим последовал выпрямленный линейный блок (ReLu), чтобы ввести нелинейность, чтобы улучшить классификацию модели и сократить время вычислений, поскольку в предыдущих моделях использовались функции tanh или сигмовидной формы, это оказалось намного лучше, чем те.
* реализовано три полностью связанных уровня, из которых первые два имеют размер 4096, а после этого уровень с 1000 каналами для 1000-позиционной классификации ILSVRC, а последний уровень является функцией softmax.

## DeconvNet

[Статья с описанием](https://www.cv-foundation.org/openaccess/content_iccv_2015/papers/Noh_Learning_Deconvolution_Network_ICCV_2015_paper.pdf)

Сеть состоит из двух частей—свертки и деконволюции. Сеть свертки соответствует извлекателю признаков, который преобразует входное изображение в многомерное представление признаков, в то время как сеть деконволюции - это генератор форм, который производит сегментацию объектов из функции, извлеченной из сети свертки. Конечным выходом сети является вероятностная карта того же размера, что и входное изображение, указывающая вероятность каждого пикселя, принадлежащего одному из предопределенных классов. Используется 16-слойная сеть VGG для сверточной части с удаленным последним классификационным слоем. В итоге сверточная сеть имеет в общей сложности 13 сверточных слоев, операции выпрямления и объединения иногда выполняются между сверточками, а 2 полностью связанных слоя дополняются в конце, чтобы наложить проекцию конкретного класса. 

## SegNet   

[Статья с описанием](https://arxiv.org/pdf/1511.00561.pdf)
[Краткое описание](https://towardsdatascience.com/review-segnet-semantic-segmentation-e66f2e30fb96)

Имеет сеть кодировщика и соответствующую сеть декодирования, за которыми следует последний уровень классификации по пикселям

В *кодировщике* выполняются свертки и max pooling.
     * Есть 13 сверточных слоев из VGG-16. (Исходные полностью связанные слои отбрасываются.)
     * При выполнении max-pooling 2×2 сохраняются соответствующие индексы (местоположения) max pooling.

*Декодер*
Повышение дискретизации с использованием индексов максимального объединения
     * В декодере выполняется повышающая дискретизация и свертки. В конце есть классификатор softmax для каждого пикселя.
     * Во время повышающей дискретизации максимальные индексы объединения на соответствующем уровне кодера вызываются для повышения дискретизации.
     * Наконец, классификатор softmax K-класса используется для прогнозирования класса для каждого пикселя. 

## U-Net
[Статья с описанием](https://arxiv.org/pdf/1505.04597v1.pdf)

Это архитектура семантической сегментации. Она состоит из пути сжатия и пути расширения. Путь сжатия соответствует типичной архитектуре сверточной сети. Он состоит из повторного применения двух сверток 3x3 (неупакованных сверток), каждая из которых сопровождается выпрямленным линейным блоком (ReLU) и операцией объединения 2x2 max pooling с шагом 2 для понижающей дискретизации. На каждом шаге понижающей дискретизации мы удваиваем количество функциональных каналов. Каждый шаг в расширяющемся пути состоит из восходящей выборки карты объектов, за которой следует свертка 2x2 (“восходящая свертка”), которая вдвое уменьшает количество каналов объектов, конкатенация с соответствующей обрезанной картой объектов из сокращающегося пути и две свертки 3x3, каждая из которых сопровождается ReLU. Обрезка необходима из-за потери граничных пикселей в каждой свертке. На последнем слое свертка 1x1 используется для сопоставления каждого 64-компонентного вектора признаков с желаемым числом классов. В общей сложности сеть имеет 23 сверточных слоя.
